# EEBot 文檔分段規則

> **文檔版本**: 1.0
> **制定日期**: 2025-11-24
> **適用範圍**: 所有給 AI 讀取的專案文檔
> **專案代號**: Gleipnir (格萊普尼爾)

---

## 📋 目錄

- [背景說明](#背景說明)
- [統一分段標準](#統一分段標準)
- [分段格式規範](#分段格式規範)
- [適用文檔範圍](#適用文檔範圍)
- [分段執行流程](#分段執行流程)
- [自動化實施](#自動化實施) ⭐ NEW
- [導航模板](#導航模板)
- [實施案例](#實施案例)
- [與現有規則的關係](#與現有規則的關係)

---

## 🎯 背景說明

### 問題

AI 代碼助手（如 Claude Code CLI）的 Read 工具有檔案大小限制：
- **Token 限制**: 最大 25,000 tokens
- **超過限制**: 無法一次性完整讀取，需使用 offset/limit 參數分段讀取

### 影響

當專案文檔（如交接文檔、變更日誌）過大時：
- ❌ AI 無法快速獲取完整上下文
- ❌ 需要多次手動分段讀取
- ❌ 影響工作效率

### 解決方案

**主動分段策略**: 將超過限制的文檔預先分割成多個小檔案，確保 AI 可以順暢讀取。

---

## 📏 統一分段標準

### 觸發條件（任一符合即需分段）

| 指標 | 閾值 | 說明 |
|------|------|------|
| **Token 數量** | **≥ 20,000 tokens** | 留 5,000 token 緩衝 |
| **檔案大小** | **≥ 60 KB** | 經驗值（約 20,000 tokens） |
| **行數** | **≥ 2,000 行** | 適用於程式碼密集型文檔 |

**為何設定 20,000 tokens？**
- Read 工具限制: 25,000 tokens
- 安全緩衝: 5,000 tokens（20%）
- 避免臨界狀態導致讀取失敗

---

### 目標分段大小

每個分段應符合以下標準：

| 指標 | 目標值 | 上限值 |
|------|--------|--------|
| **Token 數量** | 15,000-18,000 | ≤ 20,000 |
| **檔案大小** | 40-50 KB | ≤ 60 KB |
| **行數** | 1,000-1,500 | ≤ 2,000 |

**設計原則**:
- ✅ 平衡分段大小（避免過小或過大）
- ✅ 在邏輯章節邊界分段（不在段落中間切斷）
- ✅ 保持內容完整性

---

## 📂 分段格式規範

### 檔名格式

```
{原檔名}-{segment}.md

範例：
原檔案: CLAUDE_CODE_HANDOVER.md
分段後:
├── CLAUDE_CODE_HANDOVER-1.md  (第1段)
├── CLAUDE_CODE_HANDOVER-2.md  (第2段)
└── CLAUDE_CODE_HANDOVER-3.md  (第3段，若需要）
```

**命名規則**:
- ✅ 使用連字號 `-` 分隔
- ✅ 數字從 `1` 開始編號
- ✅ 保持原檔名作為前綴
- ❌ 不使用底線 `_` （避免與日期格式混淆）

---

### 導航連結格式

每個分段檔案**開頭**必須包含導航區塊：

```markdown
# {文檔標題} (第 {N} 段)

> **分段資訊**: 本文檔共 {總段數} 段
> - 📄 **當前**: 第 {N} 段 - {當前段主題}
> - ⬅️ **上一段**: [{檔名}](./{檔名}) *(若不是第1段)*
> - ➡️ **下一段**: [{檔名}](./{檔名}) *(若不是最後一段)*
> - 📑 **完整索引**: [返回索引](./README.md) *(可選)*

---

## 📖 本段內容

- [章節1](#章節1)
- [章節2](#章節2)
- ...

---
```

每個分段檔案**結尾**必須包含結束標記：

```markdown
---

**本段結束**

📍 繼續閱讀: [{下一段檔名}](./{下一段檔名})
*(若為最後一段，則改為 "✅ 文檔已全部閱讀完畢")*
```

---

## 📚 適用文檔範圍

### 必須遵守此規則的文檔

| 文檔類型 | 檔名模式 | 說明 |
|---------|---------|------|
| **AI 交接文檔** | `docs/AI_ASSISTANT_GUIDE.md` | 通用 AI 助手指南 |
| **Claude Code 交接** | `docs/CLAUDE_CODE_HANDOVER.md` | Claude Code 專用 |
| **變更日誌** | `docs/CHANGELOG.md` | 最新版本記錄 |
| **工作日誌** | `docs/DAILY_WORK_LOG_*.md` | 每日工作記錄 |
| **架構文檔** | `docs/ARCHITECTURE.md` | 系統架構說明（若有） |
| **開發指南** | `docs/DEVELOPMENT_GUIDE.md` | 開發者手冊（若有） |

### 豁免文檔

以下文檔**不受此規則限制**（因為不需要 AI 完整讀取）：

- ❌ `README.md` - 簡要說明，通常較短
- ❌ `LICENSE` - 授權條款，不需 AI 解析
- ❌ `requirements.txt` - 依賴清單，結構化資料
- ❌ 原始碼檔案 (`.py`, `.js` 等) - 按需讀取

---

## 🔧 分段執行流程

### Step 1: 檢測是否需要分段

```bash
# 檢查行數
wc -l docs/{檔名}.md

# 檢查檔案大小（bytes）
wc -c docs/{檔名}.md

# 判斷:
# - 行數 ≥ 2000 → 需要分段
# - 大小 ≥ 60KB (61440 bytes) → 需要分段
```

### Step 2: 確定分段點

**原則**:
1. ✅ 在主要章節邊界分段（`## ` 標題處）
2. ✅ 避免在程式碼區塊、列表中間切斷
3. ✅ 保持邏輯完整性

**方法**:
```bash
# 列出所有主要章節
grep -n "^## " docs/{檔名}.md

# 根據行數計算分段點
# 例如：2000 行文檔分成 2 段 → 在第 1000 行附近找章節邊界
```

### Step 3: 執行分段

```bash
# 第1段: 1 到 N 行
head -n {N} docs/{檔名}.md > docs/{檔名}-1.md

# 第2段: N+1 到結尾
tail -n +{N+1} docs/{檔名}.md > docs/{檔名}-2.md

# 第3段以此類推...
```

### Step 4: 添加導航連結

- 在每個分段開頭添加導航區塊
- 在每個分段結尾添加結束標記
- 建立分段檔案間的雙向連結

### Step 5: 處理原始檔案

**選項 A: 保留為索引檔**
- 將原檔案改寫為索引頁
- 包含所有分段的連結
- 提供完整目錄

**選項 B: 移除原始檔案**
- 刪除或重新命名原檔案
- 將第1段作為入口點
- 在 README.md 中更新連結

**建議**: 使用選項 A（保留索引檔），方便快速導航

### Step 6: 更新文檔索引

更新以下檔案中的文檔連結：
- `README.md`
- `docs/AI_ASSISTANT_GUIDE.md`
- `docs/CLAUDE_CODE_HANDOVER.md`（若為索引檔）

---

## 🤖 自動化實施

### 自動檢測工具

專案提供自動化檢測腳本 `tools/check_doc_size.py`，可自動掃描並檢測文檔大小。

#### 工具功能

- **自動掃描**: 遞迴掃描 `docs/` 目錄下所有 `.md` 文檔
- **智能過濾**: 自動排除不需要檢查的文檔（README.md, LICENSE 等）
- **多維度檢測**:
  - 行數統計
  - 檔案大小（KB/MB）
  - Token 數量估算（估算公式：byte_size / 3.7）
- **閾值判斷**: 根據本規則的標準自動判斷是否需要分段
- **詳細報告**: 生成完整的檢測報告

#### 使用方法

```bash
# 在專案根目錄執行
python tools/check_doc_size.py
```

**輸出範例**:
```
====================================================================================================
[INFO] EEBot 文檔大小檢測報告
====================================================================================================

[統計] 總文檔數: 10
[OK] 正常文檔: 8
[WARNING] 需要分段: 2

====================================================================================================

[WARNING] 以下文檔超過閾值，建議分段:
----------------------------------------------------------------------------------------------------

[FILE] docs\AI_ASSISTANT_GUIDE.md
   行數: 2,554 行
   大小: 80.6 KB
   Token (估算): 22,307
   超過閾值:
      * Token 數量: 22,307 >= 20,000
      * 檔案大小: 80.6 KB >= 60 KB
      * 行數: 2,554 >= 2,000

====================================================================================================
```

#### 檢測結果解讀

**退出碼**:
- `0`: 所有文檔大小正常 ✅
- `1`: 發現需要分段的文檔 ⚠️

**超過閾值的處理**:
1. **Token 數量 >= 20,000**: 必須分段（AI 讀取限制）
2. **檔案大小 >= 60 KB**: 建議分段（接近或超過限制）
3. **行數 >= 2,000**: 建議分段（內容過長）

任何一項超過閾值即觸發分段建議。

### 自動化建議

#### 方案 1: Git Pre-commit Hook ⭐ 已實施

**本專案已配置 Python 版 Pre-commit Hook**，位於 `.git/hooks/pre-commit`。

**運作機制**:
1. 自動檢測暫存區中的 `docs/*.md` 文檔（排除已分段的 `-1.md`, `-2.md` 等）
2. 使用與 `check_doc_size.py` 相同的閾值標準
3. 如果發現超過閾值的文檔，**自動阻止提交**並顯示詳細報告

**範例輸出**:
```
[INFO] Checking document sizes before commit...

============================================================
[ERROR] Commit blocked! Oversized documents detected:
============================================================

[!] docs/NEW_FEATURE_DOC.md
    - Token: 25,000 >= 20,000
    - Size: 75.0 KB >= 60 KB
    - Lines: 2,300 >= 2,000

------------------------------------------------------------
[ACTION REQUIRED]
Please segment these documents before committing:
  1. Run: python tools/check_doc_size.py
  2. Follow the prompts to segment oversized documents
  3. Review the segmented files
  4. Try committing again
------------------------------------------------------------
```

**優點**:
- ✅ 提交前自動檢測
- ✅ **強制阻止**超大文檔被提交（非可選）
- ✅ 只檢測即將提交的文檔（高效）
- ✅ 防止意外提交未分段的大型文檔

**缺點**:
- ⚠️ Hook 需要在 `.git/hooks/` 目錄（無法通過 Git 共享）
- ⚠️ 團隊成員需要手動複製 hook 或執行安裝腳本

**啟用方法**（如果 hook 不存在）:
```bash
# Hook 已存在於 .git/hooks/pre-commit
# 如果不存在，可以從範本複製
chmod +x .git/hooks/pre-commit
```

#### 方案 2: CI/CD 集成

在 GitHub Actions / GitLab CI 中添加檢測步驟：

```yaml
# .github/workflows/doc-check.yml
name: Document Size Check

on: [push, pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: '3.x'
      - name: Check document size
        run: |
          python tools/check_doc_size.py
        continue-on-error: true  # 允許失敗但顯示警告
```

**優點**:
- ✅ 自動執行，無需手動設置
- ✅ 可視化報告
- ✅ 團隊協作友好

**缺點**:
- ⚠️ 需要 CI/CD 環境

#### 方案 3: 定期手動檢查

建議時機：
1. ✅ **每次更新文檔後**: 確認是否需要分段
2. ✅ **每週一次**: 定期檢查所有文檔
3. ✅ **發布前**: 確保文檔符合標準

```bash
# 建立快捷腳本 check-docs.sh
#!/bin/bash
cd "$(dirname "$0")"
python tools/check_doc_size.py
```

### 工具配置

#### 自訂檢測範圍

編輯 `tools/check_doc_size.py`:

```python
# 需要檢查的文檔目錄
DOC_DIRECTORIES = ["docs"]

# 需要檢查的文件類型
FILE_PATTERNS = ["*.md"]

# 排除的文件
EXCLUDED_FILES = {
    "README.md",
    "LICENSE",
    "LICENSE.md",
}

# 排除的文件名模式
EXCLUDED_PATTERNS = [
    "CHANGELOG_archive_*.md",  # 歸檔文件不需要再次檢查
    "DAILY_WORK_LOG_*.md",    # 工作日誌使用獨立規則
]
```

#### 調整閾值

```python
# 分段閾值
THRESHOLDS = {
    "tokens": 20000,       # >= 20,000 tokens
    "bytes": 60 * 1024,    # >= 60 KB
    "lines": 2000          # >= 2,000 行
}
```

### 最佳實踐

1. **定期檢測**: 每週執行一次 `python tools/check_doc_size.py`
2. **提交前檢查**: 更新文檔後執行檢測
3. **主動分段**: 發現接近閾值（例如 18,000 tokens）時主動分段
4. **記錄操作**: 分段後在 CHANGELOG.md 中記錄

### 故障排查

#### Windows 編碼問題

如果在 Windows 上看到亂碼：
```bash
# 使用 UTF-8 編碼執行
python -X utf8 tools/check_doc_size.py

# 或設置環境變數
set PYTHONUTF8=1
python tools/check_doc_size.py
```

#### 執行權限問題

Linux/macOS 上添加執行權限：
```bash
chmod +x tools/check_doc_size.py
./tools/check_doc_size.py
```

---

## 📝 導航模板

### 分段檔案開頭模板

```markdown
# {文檔標題} (第 {N} 段)

> **分段資訊**: 本文檔共 3 段
> - 📄 **當前**: 第 2 段 - 進階功能詳解
> - ⬅️ **上一段**: [CLAUDE_CODE_HANDOVER-1.md](./CLAUDE_CODE_HANDOVER-1.md)
> - ➡️ **下一段**: [CLAUDE_CODE_HANDOVER-3.md](./CLAUDE_CODE_HANDOVER-3.md)
> - 📑 **完整索引**: [返回索引](./CLAUDE_CODE_HANDOVER.md)

---

## 📖 本段內容

- [章節A](#章節a)
- [章節B](#章節b)

---

{開始正文內容...}
```

### 分段檔案結尾模板

```markdown
---

**本段結束**

📍 繼續閱讀: [CLAUDE_CODE_HANDOVER-3.md](./CLAUDE_CODE_HANDOVER-3.md)

---

*文檔版本: 2.0 | 最後更新: 2025-11-24 | 專案: Gleipnir*
```

### 索引檔案模板（原始檔案改寫）

```markdown
# {文檔標題} - 索引

> **注意**: 本文檔因檔案過大已分段，請選擇對應章節閱讀。

---

## 📑 分段導航

### [第 1 段: 基礎架構與使用指南](./CLAUDE_CODE_HANDOVER-1.md)
- 項目代號與快速開始
- 項目概述與架構
- 核心概念
- 常見任務指南
- 禁止修改清單
- ...

### [第 2 段: 進階功能詳解](./CLAUDE_CODE_HANDOVER-2.md)
- 自動答題系統
- 智能模式
- GUI 開發計畫
- ...

### [第 3 段: 附錄與延伸](./CLAUDE_CODE_HANDOVER-3.md)
- 延伸閱讀
- 常見問題
- ...

---

## 📊 文檔統計

| 項目 | 數值 |
|------|------|
| 總行數 | 2,159 |
| 總大小 | 63.6 KB |
| Token 數 | 26,923 |
| 分段數 | 2 |

---

## 🔗 快速連結

- 📘 [完整閱讀第1段](./CLAUDE_CODE_HANDOVER-1.md)
- 🎯 [直接跳到自動答題系統](./CLAUDE_CODE_HANDOVER-2.md#已完成功能自動答題系統-phase-2)
- 🎨 [GUI 開發計畫](./CLAUDE_CODE_HANDOVER-2.md#gui-開發計畫-2025-11-24-規劃)

---

*索引建立日期: 2025-11-24 | 專案版本: 2.0.5*
```

---

## 📚 實施案例

### 案例 1: CLAUDE_CODE_HANDOVER.md

**原始狀態**:
- 行數: 2,159 行
- 大小: 63.6 KB
- Token: 26,923 tokens ❌ **超過 25,000 限制**

**分段方案**:
- **第1段 (Lines 1-1005)**: 基礎架構與使用指南 (~12,000 tokens)
- **第2段 (Lines 1006-2159)**: 進階功能詳解 (~14,900 tokens)

**分段檔案**:
```
docs/
├── CLAUDE_CODE_HANDOVER.md        (改為索引檔)
├── CLAUDE_CODE_HANDOVER-1.md      (基礎架構)
└── CLAUDE_CODE_HANDOVER-2.md      (進階功能)
```

**效果**:
- ✅ 每個分段都在 20,000 token 以內
- ✅ AI 可以順暢讀取
- ✅ 邏輯分界清晰

---

### 案例 2: AI_ASSISTANT_GUIDE.md (預防性監控)

**當前狀態**:
- 行數: 2,545 行
- 大小: 80 KB
- Token: ~24,000 tokens ✅ **尚未超過限制**

**狀態**: 🟡 **接近閾值，需監控**

**建議**:
- 當新增內容導致超過 2,000 行或 60 KB 時，立即執行分段

---

## 🔄 與現有規則的關係

### 現有文檔管理規則

專案中已存在以下文檔管理規則：

#### 1. CHANGELOG.md 拆分策略 (制定於 2025-01-17)

**原規則**:
- 觸發條件: **≥ 400 行**或 **≥ 15 KB**
- 拆分方式: 舊版本移至 `docs/changelogs/CHANGELOG_archive_YYYY.md`
- 主文件保留: 最新 2-3 個版本

**與本規則的關係**:
- ✅ **互補關係**: CHANGELOG 使用歸檔策略（按時間分離）
- ✅ **本規則補充**: 若單一歸檔檔案過大（≥ 2,000 行），再使用分段策略
- ✅ **優先級**: CHANGELOG 優先使用歸檔策略，再考慮分段

#### 2. 工作日誌檔名規範 (制定於 2025-11-24)

**原規則**:
- 檔名格式: `DAILY_WORK_LOG_yyyymmddhhmm.md`
- 分段觸發: **≥ 500 行**或 **≥ 20 KB**
- 分段格式: `DAILY_WORK_LOG_yyyymmddhhmm-{num}.md`

**與本規則的關係**:
- ✅ **完全相容**: 工作日誌已有分段機制
- ✅ **標準統一**: 工作日誌分段格式與本規則一致
- ✅ **閾值差異**: 工作日誌較小（500 行），交接文檔較大（2,000 行）

---

### 統一後的規則體系

```
📋 EEBot 文檔管理規則體系

├── 通用分段規則 (本文檔)
│   ├── 適用: 所有 AI 可讀文檔
│   ├── 閾值: ≥ 2,000 行 / ≥ 60 KB / ≥ 20,000 tokens
│   └── 格式: {檔名}-{num}.md
│
├── CHANGELOG 專用規則
│   ├── 策略: 歸檔 + 分段
│   ├── 歸檔閾值: ≥ 400 行 / ≥ 15 KB
│   └── 分段閾值: 使用通用規則
│
└── 工作日誌專用規則
    ├── 檔名: DAILY_WORK_LOG_yyyymmddhhmm.md
    ├── 分段閾值: ≥ 500 行 / ≥ 20 KB
    └── 分段格式: DAILY_WORK_LOG_yyyymmddhhmm-{num}.md
```

**規則優先級**:
1. **特定規則優先**: CHANGELOG、工作日誌優先使用各自規則
2. **通用規則補充**: 若特定規則未覆蓋，使用本通用規則
3. **定期審查**: 每季度審查閾值設定是否合理

---

## 📊 實施檢查清單

### 分段前檢查

- [ ] 檔案是否超過閾值（2,000 行 / 60 KB / 20,000 tokens）
- [ ] 是否為 AI 可讀文檔類型
- [ ] 確認分段點位於邏輯章節邊界
- [ ] 確認每個分段大小適中（1,000-1,500 行）

### 分段執行檢查

- [ ] 分段檔案已建立（檔名格式正確）
- [ ] 每個分段開頭包含導航區塊
- [ ] 每個分段結尾包含結束標記
- [ ] 分段間導航連結正確無誤

### 分段後檢查

- [ ] 原始檔案已處理（改為索引或移除）
- [ ] 相關文檔索引已更新
- [ ] 測試：使用 Read 工具讀取每個分段，確認成功
- [ ] Git 提交訊息清晰記錄分段操作

---

## 🔍 常見問題

### Q1: 為何不使用 offset/limit 參數分段讀取？

**A**:
- ❌ 需要多次手動操作
- ❌ 無法快速建立完整上下文
- ✅ 預先分段一勞永逸

### Q2: 分段後原始檔案如何處理？

**A**: 建議保留為索引檔（選項 A），方便快速導航。

### Q3: 如何處理跨分段的內部連結？

**A**:
- 使用相對路徑: `[標題](./檔名-2.md#章節)`
- 在索引檔中提供完整導航

### Q4: 分段閾值是否可調整？

**A**:
- 可以根據實際使用經驗調整
- 建議每季度審查一次
- 調整後更新本文檔

### Q5: 如何處理已分段的文檔需要更新？

**A**:
1. 在對應分段檔案中直接修改
2. 若新增內容導致分段過大，重新分段
3. 更新所有相關導航連結

---

## 📅 版本歷史

| 版本 | 日期 | 變更內容 |
|------|------|---------|
| 1.0 | 2025-11-24 | 初版發布，統一文檔分段規則 |

---

## 📞 維護者

**文檔維護**: wizard03
**專案代號**: Gleipnir (格萊普尼爾)
**專案版本**: 2.0.5

---

**Happy Documenting! 📚**

*本規則文檔也需遵守分段規則。當本文檔超過 2,000 行時，請執行分段。*
