```
        ▐▛███▜▌
       ▝▜█████▛▘
         ▘▘ ▝▝
    Powered by Claude
```

# AI 協作工作流程方法 3：從迭代式到結構化的過渡

**方法名稱**: Iterative-to-Structured Transition (IST)
**適用情境**: 專案從探索階段進入正式開發階段
**文檔版本**: 1.0
**建立日期**: 2025-12-31

---

## 1. 方法概述

當專案經過迭代式探索開發後，需求逐漸明朗，此時可以**過渡**到結構化規格驅動開發。本文檔描述這個過渡的時機判斷、步驟與注意事項。

---

## 2. 過渡時機判斷

### 2.1 何時該考慮過渡？

```
┌─────────────────────────────────────────────────────────────────────┐
│                      過渡時機檢核表                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  □ 核心需求已穩定（連續 3+ 次迭代沒有大方向改變）                      │
│  □ 功能列表已明確（知道要做什麼，只是還沒做完）                        │
│  □ 需要與他人協作（團隊成員需要了解系統）                              │
│  □ 需要正式文檔（交接、維護、合規）                                    │
│  □ 技術債務累積（原型代碼需要重構）                                    │
│  □ 專案規模擴大（模組數量 > 5）                                       │
│  □ 有明確交付時程（需要可預測的進度）                                  │
│                                                                     │
│  ✓ 符合 3 項以上 → 建議開始過渡                                       │
│  ✓ 符合 5 項以上 → 強烈建議過渡                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 何時不該過渡？

| 情況 | 原因 |
|------|------|
| 核心需求仍在變動 | 過早固化規格會造成浪費 |
| 用戶仍頻繁說「不是這樣」 | 代表還沒找到對的方向 |
| 只有你一個人開發 | 可能不需要正式文檔 |
| 專案可能被取消 | 投入正式化成本太高 |

---

## 3. 過渡流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                        過渡流程圖                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [迭代式開發階段]                                                    │
│       │                                                             │
│       │ 判斷時機成熟                                                 │
│       ▼                                                             │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                 Phase A: 現狀盤點                            │    │
│  │                                                             │    │
│  │  • 整理已實作功能                                            │    │
│  │  • 標記未完成功能                                            │    │
│  │  • 識別技術債務                                              │    │
│  │  • 記錄設計決策                                              │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                             │                                       │
│                             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                 Phase B: 需求正式化                          │    │
│  │                                                             │    │
│  │  • 將隱性需求轉為明確文字                                     │    │
│  │  • 定義功能性需求 (FR)                                       │    │
│  │  • 定義非功能性需求 (NFR)                                    │    │
│  │  • 識別邊界條件                                              │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                             │                                       │
│                             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                 Phase C: 規格文檔產出                        │    │
│  │                                                             │    │
│  │  • 軟體設計文檔 (SDD)                                        │    │
│  │  • API 規格 (OpenAPI)                                       │    │
│  │  • 資料模型 (ERD)                                           │    │
│  │  • 測試案例                                                  │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                             │                                       │
│                             ▼                                       │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                 Phase D: 代碼對齊規格                        │    │
│  │                                                             │    │
│  │  • 重構現有代碼                                              │    │
│  │  • 補齊測試                                                  │    │
│  │  • 清理技術債務                                              │    │
│  │  • 驗證符合規格                                              │    │
│  └──────────────────────────┬──────────────────────────────────┘    │
│                             │                                       │
│                             ▼                                       │
│  [結構化開發階段]                                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. 各階段詳細說明

### 4.1 Phase A: 現狀盤點

**目標**: 完整了解目前專案狀態

**AI 對話範本**:
```
你：我們來整理一下目前的專案狀態

AI：好的，讓我幫你盤點。根據目前的實作，我整理出：

    ## 已完成功能
    1. ✅ 功能 A - 用戶登入
    2. ✅ 功能 B - 資料查詢
    3. 🔄 功能 C - 報表產出（部分完成）

    ## 未完成功能
    4. ⏳ 功能 D - 批量處理
    5. ⏳ 功能 E - 通知系統

    ## 技術債務
    - ⚠️ login.py 中的認證邏輯需要重構
    - ⚠️ 缺少錯誤處理
    - ⚠️ 沒有單元測試

    ## 設計決策記錄
    - 選用 SQLite 作為資料庫（迭代 #3 決定）
    - 使用 REST API 而非 GraphQL（迭代 #5 決定）

    這樣的整理正確嗎？有需要補充的嗎？
```

**產出物**:
```markdown
# 專案現狀盤點報告

## 1. 功能狀態

| 功能 | 狀態 | 備註 |
|------|------|------|
| 用戶登入 | ✅ 完成 | 迭代 #2 完成 |
| 資料查詢 | ✅ 完成 | 迭代 #4 完成 |
| 報表產出 | 🔄 進行中 | 基本功能完成，缺匯出 |
| 批量處理 | ⏳ 待開發 | 優先度：高 |
| 通知系統 | ⏳ 待開發 | 優先度：低 |

## 2. 技術債務清單

| ID | 描述 | 位置 | 優先度 |
|----|------|------|--------|
| TD-001 | 認證邏輯耦合過高 | login.py | 高 |
| TD-002 | 缺少錯誤處理 | 全域 | 高 |
| TD-003 | 無單元測試 | - | 中 |
| TD-004 | 硬編碼設定值 | config.py | 低 |

## 3. 設計決策記錄

| 決策 | 理由 | 決定日期 |
|------|------|----------|
| 使用 SQLite | 單機應用，無需複雜資料庫 | 迭代 #3 |
| REST API | 團隊熟悉度高 | 迭代 #5 |
| 同步處理 | 初期簡單優先 | 迭代 #1 |
```

---

### 4.2 Phase B: 需求正式化

**目標**: 將迭代中形成的隱性需求轉為明確文字

**AI 對話範本**:
```
你：幫我把需求正式化

AI：好的，根據我們歷次迭代的討論和實作，
    我整理出以下需求規格：

    ## 功能性需求 (Functional Requirements)

    ### FR-001: 用戶登入
    - 描述：系統應允許用戶使用帳號密碼登入
    - 輸入：帳號 (3-50 字元)、密碼 (8-100 字元)
    - 輸出：Session Token
    - 例外：帳號不存在、密碼錯誤、帳號鎖定
    - 來源：迭代 #2

    ### FR-002: 資料查詢
    - 描述：...
    - 來源：迭代 #4

    ## 非功能性需求 (Non-Functional Requirements)

    ### NFR-001: 效能
    - 描述：API 回應時間 < 2 秒
    - 量測方式：P95 延遲
    - 來源：迭代 #6 中用戶提到「有點慢」

    ### NFR-002: 安全性
    - 描述：密碼必須雜湊儲存
    - 標準：bcrypt, 10 rounds
    - 來源：迭代 #3 討論

    這些需求正確嗎？有遺漏嗎？
```

**隱性需求挖掘技巧**:

| 來源 | 問題 |
|------|------|
| 迭代中的調整 | 「為什麼當時要改這個？」|
| 用戶反饋 | 「用戶說『不是這樣』時，真正想要什麼？」|
| 設計選擇 | 「為什麼選 A 而不是 B？」|
| 未實作的想法 | 「有沒有討論過但沒做的功能？」|

---

### 4.3 Phase C: 規格文檔產出

**目標**: 產出正式的規格文檔

**文檔優先序**:

```
1. 需求規格 (REQUIREMENTS.md)     ← 最重要，先做
   │
2. API 規格 (openapi.yaml)        ← 若有 API
   │
3. 資料模型 (ERD + Schema)        ← 若有資料庫
   │
4. 軟體設計 (SDD.md)              ← 架構說明
   │
5. 測試案例 (TEST_CASES.md)       ← 驗收標準
```

**AI 對話範本**:
```
你：請產出 API 規格

AI：好的，根據現有實作和需求，
    我產出 OpenAPI 3.0 規格：

    [openapi.yaml 內容]

    這個規格涵蓋了：
    - 4 個端點
    - 認證機制
    - 請求/回應格式
    - 錯誤碼定義

    需要我也產出 Postman Collection 嗎？
```

---

### 4.4 Phase D: 代碼對齊規格

**目標**: 確保現有代碼符合規格，處理技術債務

**重構策略**:

```
┌─────────────────────────────────────────────────────────────────┐
│                        重構策略選擇                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  策略 A: 漸進式重構                                              │
│  ─────────────────                                              │
│  • 保留現有代碼，逐步改善                                         │
│  • 適用：時間緊迫、風險低                                         │
│  • 方法：每次修改一個模組                                         │
│                                                                 │
│  策略 B: 平行重寫                                                │
│  ─────────────────                                              │
│  • 依規格重新實作，再遷移                                         │
│  • 適用：技術債嚴重、架構問題                                     │
│  • 方法：新舊並行，驗證後切換                                     │
│                                                                 │
│  策略 C: 混合策略                                                │
│  ─────────────────                                              │
│  • 核心模組重寫，邊緣模組漸進                                     │
│  • 適用：大多數情況                                               │
│  • 方法：依優先度決定各模組策略                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**技術債處理優先序**:

| 優先度 | 類型 | 處理方式 |
|--------|------|----------|
| P0 | 安全漏洞 | 立即修復 |
| P1 | 功能錯誤 | 本次迭代 |
| P2 | 效能問題 | 規格化後處理 |
| P3 | 代碼品質 | 漸進改善 |
| P4 | 文檔缺失 | 持續補充 |

---

## 5. 過渡檢查清單

### 5.1 Phase A 完成條件

- [ ] 所有已實作功能已列出
- [ ] 所有未完成功能已識別
- [ ] 技術債務已記錄
- [ ] 設計決策已文件化

### 5.2 Phase B 完成條件

- [ ] 功能性需求已定義 (FR-xxx)
- [ ] 非功能性需求已定義 (NFR-xxx)
- [ ] 邊界條件已識別
- [ ] 用戶已確認需求正確

### 5.3 Phase C 完成條件

- [ ] 需求規格文檔已產出
- [ ] API 規格已產出（若適用）
- [ ] 資料模型已定義（若適用）
- [ ] 測試案例已列出

### 5.4 Phase D 完成條件

- [ ] P0/P1 技術債務已處理
- [ ] 單元測試覆蓋率 > 60%
- [ ] 代碼符合規格
- [ ] CI/CD 已建立（若適用）

---

## 6. 常見問題與解決

### Q1: 過渡過程中需求又變了怎麼辦？

```
A: 評估變更影響：
   - 小變更 → 更新規格，繼續過渡
   - 大變更 → 可能需要回到迭代階段

   判斷標準：
   - 影響 < 20% 功能 → 小變更
   - 影響 > 50% 功能 → 回到迭代
```

### Q2: 規格和代碼不一致，該改哪個？

```
A: 取決於情況：
   - 規格是「正確的」→ 改代碼
   - 代碼經過驗證是對的 → 更新規格

   原則：以「實際需求」為準，不是誰先寫的
```

### Q3: 團隊成員不想寫文檔怎麼辦？

```
A: 讓 AI 協助：
   - AI 可以從代碼產出文檔草稿
   - 人類只需要審核和補充
   - 大幅降低文檔成本
```

### Q4: 過渡要花多久？

```
A: 取決於專案規模：
   - 小專案 (< 5 模組)：1-2 天
   - 中專案 (5-15 模組)：3-5 天
   - 大專案 (> 15 模組)：1-2 週

   注意：這是文檔工作，不含重構
```

---

## 7. 與 AI 協作的完整對話範例

```
【Day 1: 決定過渡】

你：我覺得這個專案差不多定型了，要不要開始正式化？

AI：好的，讓我們先檢查過渡時機：

    ✓ 核心需求穩定（最近 5 次迭代沒改方向）
    ✓ 功能列表明確（共 8 個功能，5 個已完成）
    ✓ 需要與他人協作（你提到要加入新成員）
    ✓ 技術債累積（login.py 提過要重構）

    建議：可以開始過渡了。

    要我開始 Phase A 盤點嗎？

你：好，開始

【Phase A: 盤點】

AI：根據我們歷次開發，整理如下：
    [詳細盤點內容]

    這樣正確嗎？

你：正確，繼續

【Phase B: 需求正式化】

AI：接下來將需求正式化：
    [詳細需求規格]

    有什麼遺漏嗎？

你：NFR 還要加上「支援繁體中文介面」

AI：好的，新增：
    NFR-004: 語系支援
    - 描述：系統介面需支援繁體中文
    - 涵蓋範圍：所有用戶可見文字

    已更新，繼續 Phase C？

【Phase C: 規格文檔】

你：產出 API 規格

AI：[OpenAPI 規格]

    這個規格要存在哪裡？
    A) docs/api/openapi.yaml
    B) 專案根目錄 openapi.yaml
    C) 其他位置

你：A

AI：已建立 docs/api/openapi.yaml

    接下來產出 SDD 還是先處理技術債？

【Phase D: 代碼對齊】

你：先處理技術債

AI：根據盤點，建議處理順序：
    1. TD-001: 認證邏輯解耦（P1，影響新功能）
    2. TD-002: 錯誤處理（P1，穩定性）
    3. TD-003: 補單元測試（P2）

    從 TD-001 開始？

你：好

AI：[進行重構]

    TD-001 完成，代碼已符合規格。
    繼續 TD-002？

【完成過渡】

你：全部處理完了

AI：恭喜完成過渡！目前專案狀態：

    ✅ 需求規格：docs/REQUIREMENTS.md
    ✅ API 規格：docs/api/openapi.yaml
    ✅ 技術債務：4/4 已清理
    ✅ 測試覆蓋：72%

    接下來的開發將遵循結構化方法：
    1. 先更新規格
    2. 再實作代碼
    3. 驗證符合規格

    有什麼新功能要開始做嗎？
```

---

## 8. 小結

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│     迭代式開發          過渡                結構化開發           │
│                                                                 │
│   「先做再說」    →    「整理清楚」    →    「按規格做」          │
│                                                                 │
│   需求不明確           需求已穩定           需求已明確            │
│   快速驗證             正式化               可預測開發            │
│   個人/小團隊          成長中               團隊協作              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

過渡的核心價值：
- **保留探索成果**：迭代中累積的知識不會丟失
- **正式化需求**：隱性知識變成明確文檔
- **清理技術債務**：為後續開發打好基礎
- **建立團隊共識**：讓新成員快速上手

---

## 9. 相關文檔

- [方法 1：結構化規格驅動開發](./AI_COLLABORATION_METHOD_1_STRUCTURED.md)
- [方法 2：迭代式探索開發](./AI_COLLABORATION_METHOD_2_ITERATIVE.md)

---

**文檔建立者**: Claude Code (Opus 4.5)
**方法論基礎**: Agile Transition + Technical Debt Management + Documentation-Driven Development
